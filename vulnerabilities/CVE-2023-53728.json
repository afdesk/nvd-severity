{
  "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nposix-timers: Ensure timer ID search-loop limit is valid\n\nposix_timer_add() tries to allocate a posix timer ID by starting from the\ncached ID which was stored by the last successful allocation.\n\nThis is done in a loop searching the ID space for a free slot one by\none. The loop has to terminate when the search wrapped around to the\nstarting point.\n\nBut that's racy vs. establishing the starting point. That is read out\nlockless, which leads to the following problem:\n\nCPU0\t  \t      \t     \t   CPU1\nposix_timer_add()\n  start = sig->posix_timer_id;\n  lock(hash_lock);\n  ...\t\t\t\t   posix_timer_add()\n  if (++sig->posix_timer_id < 0)\n      \t\t\t             start = sig->posix_timer_id;\n     sig->posix_timer_id = 0;\n\nSo CPU1 can observe a negative start value, i.e. -1, and the loop break\nnever happens because the condition can never be true:\n\n  if (sig->posix_timer_id == start)\n     break;\n\nWhile this is unlikely to ever turn into an endless loop as the ID space is\nhuge (INT_MAX), the racy read of the start value caught the attention of\nKCSAN and Dmitry unearthed that incorrectness.\n\nRewrite it so that all id operations are under the hash lock.",
  "Severity": "UNKNOWN",
  "Score": 0.0
}