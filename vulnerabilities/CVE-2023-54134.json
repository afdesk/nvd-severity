{
  "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nautofs: fix memory leak of waitqueues in autofs_catatonic_mode\n\nSyzkaller reports a memory leak:\n\nBUG: memory leak\nunreferenced object 0xffff88810b279e00 (size 96):\n  comm \"syz-executor399\", pid 3631, jiffies 4294964921 (age 23.870s)\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 08 9e 27 0b 81 88 ff ff  ..........'.....\n    08 9e 27 0b 81 88 ff ff 00 00 00 00 00 00 00 00  ..'.............\n  backtrace:\n    [<ffffffff814cfc90>] kmalloc_trace+0x20/0x90 mm/slab_common.c:1046\n    [<ffffffff81bb75ca>] kmalloc include/linux/slab.h:576 [inline]\n    [<ffffffff81bb75ca>] autofs_wait+0x3fa/0x9a0 fs/autofs/waitq.c:378\n    [<ffffffff81bb88a7>] autofs_do_expire_multi+0xa7/0x3e0 fs/autofs/expire.c:593\n    [<ffffffff81bb8c33>] autofs_expire_multi+0x53/0x80 fs/autofs/expire.c:619\n    [<ffffffff81bb6972>] autofs_root_ioctl_unlocked+0x322/0x3b0 fs/autofs/root.c:897\n    [<ffffffff81bb6a95>] autofs_root_ioctl+0x25/0x30 fs/autofs/root.c:910\n    [<ffffffff81602a9c>] vfs_ioctl fs/ioctl.c:51 [inline]\n    [<ffffffff81602a9c>] __do_sys_ioctl fs/ioctl.c:870 [inline]\n    [<ffffffff81602a9c>] __se_sys_ioctl fs/ioctl.c:856 [inline]\n    [<ffffffff81602a9c>] __x64_sys_ioctl+0xfc/0x140 fs/ioctl.c:856\n    [<ffffffff84608225>] do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n    [<ffffffff84608225>] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n    [<ffffffff84800087>] entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nautofs_wait_queue structs should be freed if their wait_ctr becomes zero.\nOtherwise they will be lost.\n\nIn this case an AUTOFS_IOC_EXPIRE_MULTI ioctl is done, then a new\nwaitqueue struct is allocated in autofs_wait(), its initial wait_ctr\nequals 2. After that wait_event_killable() is interrupted (it returns\n-ERESTARTSYS), so that 'wq->name.name == NULL' condition may be not\nsatisfied. Actually, this condition can be satisfied when\nautofs_wait_release() or autofs_catatonic_mode() is called and, what is\nalso important, wait_ctr is decremented in those places. Upon the exit of\nautofs_wait(), wait_ctr is decremented to 1. Then the unmounting process\nbegins: kill_sb calls autofs_catatonic_mode(), which should have freed the\nwaitqueues, but it only decrements its usage counter to zero which is not\na correct behaviour.\n\nedit:imk\nThis description is of course not correct. The umount performed as a result\nof an expire is a umount of a mount that has been automounted, it's not the\nautofs mount itself. They happen independently, usually after everything\nmounted within the autofs file system has been expired away. If everything\nhasn't been expired away the automount daemon can still exit leaving mounts\nin place. But expires done in both cases will result in a notification that\ncalls autofs_wait_release() with a result status. The problem case is the\nsummary execution of of the automount daemon. In this case any waiting\nprocesses won't be woken up until either they are terminated or the mount\nis umounted.\nend edit: imk\n\nSo in catatonic mode we should free waitqueues which counter becomes zero.\n\nedit: imk\nInitially I was concerned that the calling of autofs_wait_release() and\nautofs_catatonic_mode() was not mutually exclusive but that can't be the\ncase (obviously) because the queue entry (or entries) is removed from the\nlist when either of these two functions are called. Consequently the wait\nentry will be freed by only one of these functions or by the woken process\nin autofs_wait() depending on the order of the calls.\nend edit: imk",
  "Severity": "UNKNOWN",
  "Score": 0.0
}