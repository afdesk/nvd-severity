{
  "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: don't free qgroup space unless specified\n\nBoris noticed in his simple quotas testing that he was getting a leak\nwith Sweet Tea's change to subvol create that stopped doing a\ntransaction commit.  This was just a side effect of that change.\n\nIn the delayed inode code we have an optimization that will free extra\nreservations if we think we can pack a dir item into an already modified\nleaf.  Previously this wouldn't be triggered in the subvolume create\ncase because we'd commit the transaction, it was still possible but\nmuch harder to trigger.  It could actually be triggered if we did a\nmkdir && subvol create with qgroups enabled.\n\nThis occurs because in btrfs_insert_delayed_dir_index(), which gets\ncalled when we're adding the dir item, we do the following:\n\n  btrfs_block_rsv_release(fs_info, trans->block_rsv, bytes, NULL);\n\nif we're able to skip reserving space.\n\nThe problem here is that trans->block_rsv points at the temporary block\nrsv for the subvolume create, which has qgroup reservations in the block\nrsv.\n\nThis is a problem because btrfs_block_rsv_release() will do the\nfollowing:\n\n  if (block_rsv->qgroup_rsv_reserved >= block_rsv->qgroup_rsv_size) {\n\t  qgroup_to_release = block_rsv->qgroup_rsv_reserved -\n\t\t  block_rsv->qgroup_rsv_size;\n\t  block_rsv->qgroup_rsv_reserved = block_rsv->qgroup_rsv_size;\n  }\n\nThe temporary block rsv just has ->qgroup_rsv_reserved set,\n->qgroup_rsv_size == 0.  The optimization in\nbtrfs_insert_delayed_dir_index() sets ->qgroup_rsv_reserved = 0.  Then\nlater on when we call btrfs_subvolume_release_metadata() which has\n\n  btrfs_block_rsv_release(fs_info, rsv, (u64)-1, &qgroup_to_release);\n  btrfs_qgroup_convert_reserved_meta(root, qgroup_to_release);\n\nqgroup_to_release is set to 0, and we do not convert the reserved\nmetadata space.\n\nThe problem here is that the block rsv code has been unconditionally\nmessing with ->qgroup_rsv_reserved, because the main place this is used\nis delalloc, and any time we call btrfs_block_rsv_release() we do it\nwith qgroup_to_release set, and thus do the proper accounting.\n\nThe subvolume code is the only other code that uses the qgroup\nreservation stuff, but it's intermingled with the above optimization,\nand thus was getting its reservation freed out from underneath it and\nthus leaking the reserved space.\n\nThe solution is to simply not mess with the qgroup reservations if we\ndon't have qgroup_to_release set.  This works with the existing code as\nanything that messes with the delalloc reservations always have\nqgroup_to_release set.  This fixes the leak that Boris was observing.",
  "Severity": "UNKNOWN",
  "Score": 0.0
}