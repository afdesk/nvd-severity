{
  "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: idxd: Remove improper idxd_free\n\nThe call to idxd_free() introduces a duplicate put_device() leading to a\nreference count underflow:\nrefcount_t: underflow; use-after-free.\nWARNING: CPU: 15 PID: 4428 at lib/refcount.c:28 refcount_warn_saturate+0xbe/0x110\n...\nCall Trace:\n <TASK>\n  idxd_remove+0xe4/0x120 [idxd]\n  pci_device_remove+0x3f/0xb0\n  device_release_driver_internal+0x197/0x200\n  driver_detach+0x48/0x90\n  bus_remove_driver+0x74/0xf0\n  pci_unregister_driver+0x2e/0xb0\n  idxd_exit_module+0x34/0x7a0 [idxd]\n  __do_sys_delete_module.constprop.0+0x183/0x280\n  do_syscall_64+0x54/0xd70\n  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nThe idxd_unregister_devices() which is invoked at the very beginning of\nidxd_remove(), already takes care of the necessary put_device() through the\nfollowing call path:\nidxd_unregister_devices() -> device_unregister() -> put_device()\n\nIn addition, when CONFIG_DEBUG_KOBJECT_RELEASE is enabled, put_device() may\ntrigger asynchronous cleanup via schedule_delayed_work(). If idxd_free() is\ncalled immediately after, it can result in a use-after-free.\n\nRemove the improper idxd_free() to avoid both the refcount underflow and\npotential memory corruption during module unload.",
  "Severity": "UNKNOWN",
  "Score": 0.0
}