{
  "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm: fix NULL pointer dereference in __dm_suspend()\n\nThere is a race condition between dm device suspend and table load that\ncan lead to null pointer dereference. The issue occurs when suspend is\ninvoked before table load completes:\n\nBUG: kernel NULL pointer dereference, address: 0000000000000054\nOops: 0000 [#1] PREEMPT SMP PTI\nCPU: 6 PID: 6798 Comm: dmsetup Not tainted 6.6.0-g7e52f5f0ca9b #62\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014\nRIP: 0010:blk_mq_wait_quiesce_done+0x0/0x50\nCall Trace:\n  <TASK>\n  blk_mq_quiesce_queue+0x2c/0x50\n  dm_stop_queue+0xd/0x20\n  __dm_suspend+0x130/0x330\n  dm_suspend+0x11a/0x180\n  dev_suspend+0x27e/0x560\n  ctl_ioctl+0x4cf/0x850\n  dm_ctl_ioctl+0xd/0x20\n  vfs_ioctl+0x1d/0x50\n  __se_sys_ioctl+0x9b/0xc0\n  __x64_sys_ioctl+0x19/0x30\n  x64_sys_call+0x2c4a/0x4620\n  do_syscall_64+0x9e/0x1b0\n\nThe issue can be triggered as below:\n\nT1 \t\t\t\t\t\tT2\ndm_suspend\t\t\t\t\ttable_load\n__dm_suspend\t\t\t\t\tdm_setup_md_queue\n\t\t\t\t\t\tdm_mq_init_request_queue\n\t\t\t\t\t\tblk_mq_init_allocated_queue\n\t\t\t\t\t\t=> q->mq_ops = set->ops; (1)\ndm_stop_queue / dm_wait_for_completion\n=> q->tag_set NULL pointer!\t(2)\n\t\t\t\t\t\t=> q->tag_set = set; (3)\n\nFix this by checking if a valid table (map) exists before performing\nrequest-based suspend and waiting for target I/O. When map is NULL,\nskip these table-dependent suspend steps.\n\nEven when map is NULL, no I/O can reach any target because there is\nno table loaded; I/O submitted in this state will fail early in the\nDM layer. Skipping the table-dependent suspend logic in this case\nis safe and avoids NULL pointer dereferences.",
  "Severity": "UNKNOWN",
  "Score": 0.0
}