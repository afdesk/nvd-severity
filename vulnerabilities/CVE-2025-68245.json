{
  "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: netpoll: fix incorrect refcount handling causing incorrect cleanup\n\ncommit efa95b01da18 (\"netpoll: fix use after free\") incorrectly\nignored the refcount and prematurely set dev->npinfo to NULL during\nnetpoll cleanup, leading to improper behavior and memory leaks.\n\nScenario causing lack of proper cleanup:\n\n1) A netpoll is associated with a NIC (e.g., eth0) and netdev->npinfo is\n   allocated, and refcnt = 1\n   - Keep in mind that npinfo is shared among all netpoll instances. In\n     this case, there is just one.\n\n2) Another netpoll is also associated with the same NIC and\n   npinfo->refcnt += 1.\n   - Now dev->npinfo->refcnt = 2;\n   - There is just one npinfo associated to the netdev.\n\n3) When the first netpolls goes to clean up:\n   - The first cleanup succeeds and clears np->dev->npinfo, ignoring\n     refcnt.\n     - It basically calls `RCU_INIT_POINTER(np->dev->npinfo, NULL);`\n   - Set dev->npinfo = NULL, without proper cleanup\n   - No ->ndo_netpoll_cleanup() is either called\n\n4) Now the second target tries to clean up\n   - The second cleanup fails because np->dev->npinfo is already NULL.\n     * In this case, ops->ndo_netpoll_cleanup() was never called, and\n       the skb pool is not cleaned as well (for the second netpoll\n       instance)\n  - This leaks npinfo and skbpool skbs, which is clearly reported by\n    kmemleak.\n\nRevert commit efa95b01da18 (\"netpoll: fix use after free\") and adds\nclarifying comments emphasizing that npinfo cleanup should only happen\nonce the refcount reaches zero, ensuring stable and correct netpoll\nbehavior.",
  "Severity": "UNKNOWN",
  "Score": 0.0
}