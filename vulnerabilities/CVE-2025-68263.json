{
  "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nksmbd: ipc: fix use-after-free in ipc_msg_send_request\n\nipc_msg_send_request() waits for a generic netlink reply using an\nipc_msg_table_entry on the stack. The generic netlink handler\n(handle_generic_event()/handle_response()) fills entry->response under\nipc_msg_table_lock, but ipc_msg_send_request() used to validate and free\nentry->response without holding the same lock.\n\nUnder high concurrency this allows a race where handle_response() is\ncopying data into entry->response while ipc_msg_send_request() has just\nfreed it, leading to a slab-use-after-free reported by KASAN in\nhandle_generic_event():\n\n  BUG: KASAN: slab-use-after-free in handle_generic_event+0x3c4/0x5f0 [ksmbd]\n  Write of size 12 at addr ffff888198ee6e20 by task pool/109349\n  ...\n  Freed by task:\n    kvfree\n    ipc_msg_send_request [ksmbd]\n    ksmbd_rpc_open -> ksmbd_session_rpc_open [ksmbd]\n\nFix by:\n- Taking ipc_msg_table_lock in ipc_msg_send_request() while validating\n  entry->response, freeing it when invalid, and removing the entry from\n  ipc_msg_table.\n- Returning the final entry->response pointer to the caller only after\n  the hash entry is removed under the lock.\n- Returning NULL in the error path, preserving the original API\n  semantics.\n\nThis makes all accesses to entry->response consistent with\nhandle_response(), which already updates and fills the response buffer\nunder ipc_msg_table_lock, and closes the race that allowed the UAF.",
  "Severity": "UNKNOWN",
  "Score": 0.0
}