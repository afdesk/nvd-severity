{
  "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf/x86: Fix NULL event access and potential PEBS record loss\n\nWhen intel_pmu_drain_pebs_icl() is called to drain PEBS records, the\nperf_event_overflow() could be called to process the last PEBS record.\n\nWhile perf_event_overflow() could trigger the interrupt throttle and\nstop all events of the group, like what the below call-chain shows.\n\nperf_event_overflow()\n  -> __perf_event_overflow()\n    ->__perf_event_account_interrupt()\n      -> perf_event_throttle_group()\n        -> perf_event_throttle()\n          -> event->pmu->stop()\n            -> x86_pmu_stop()\n\nThe side effect of stopping the events is that all corresponding event\npointers in cpuc->events[] array are cleared to NULL.\n\nAssume there are two PEBS events (event a and event b) in a group. When\nintel_pmu_drain_pebs_icl() calls perf_event_overflow() to process the\nlast PEBS record of PEBS event a, interrupt throttle is triggered and\nall pointers of event a and event b are cleared to NULL. Then\nintel_pmu_drain_pebs_icl() tries to process the last PEBS record of\nevent b and encounters NULL pointer access.\n\nTo avoid this issue, move cpuc->events[] clearing from x86_pmu_stop()\nto x86_pmu_del(). It's safe since cpuc->active_mask or\ncpuc->pebs_enabled is always checked before access the event pointer\nfrom cpuc->events[].",
  "Severity": "UNKNOWN",
  "Score": 0.0
}