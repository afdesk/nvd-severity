{
  "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscs: fix a wrong parameter in __scs_magic\n\n__scs_magic() needs a 'void *' variable, but a 'struct task_struct *' is\ngiven.  'task_scs(tsk)' is the starting address of the task's shadow call\nstack, and '__scs_magic(task_scs(tsk))' is the end address of the task's\nshadow call stack.  Here should be '__scs_magic(task_scs(tsk))'.\n\nThe user-visible effect of this bug is that when CONFIG_DEBUG_STACK_USAGE\nis enabled, the shadow call stack usage checking function\n(scs_check_usage) would scan an incorrect memory range.  This could lead\n\n1. **Inaccurate stack usage reporting**: The function would calculate\n   wrong usage statistics for the shadow call stack, potentially showing\n   incorrect value in kmsg.\n\n2. **Potential kernel crash**: If the value of __scs_magic(tsk)is\n   greater than that of __scs_magic(task_scs(tsk)), the for loop may\n   access unmapped memory, potentially causing a kernel panic.  However,\n   this scenario is unlikely because task_struct is allocated via the slab\n   allocator (which typically returns lower addresses), while the shadow\n   call stack returned by task_scs(tsk) is allocated via vmalloc(which\n   typically returns higher addresses).\n\nHowever, since this is purely a debugging feature\n(CONFIG_DEBUG_STACK_USAGE), normal production systems should be not\nunaffected.  The bug only impacts developers and testers who are actively\ndebugging stack usage with this configuration enabled.",
  "Severity": "UNKNOWN",
  "Score": 0.0
}