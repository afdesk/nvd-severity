{
  "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nlibceph: make calc_target() set t->paused, not just clear it\n\nCurrently calc_target() clears t->paused if the request shouldn't be\npaused anymore, but doesn't ever set t->paused even though it's able to\ndetermine when the request should be paused.  Setting t->paused is left\nto __submit_request() which is fine for regular requests but doesn't\nwork for linger requests -- since __submit_request() doesn't operate\non linger requests, there is nowhere for lreq->t.paused to be set.\nOne consequence of this is that watches don't get reestablished on\npaused -> unpaused transitions in cases where requests have been paused\nlong enough for the (paused) unwatch request to time out and for the\nsubsequent (re)watch request to enter the paused state.  On top of the\nwatch not getting reestablished, rbd_reregister_watch() gets stuck with\nrbd_dev->watch_mutex held:\n\n  rbd_register_watch\n    __rbd_register_watch\n      ceph_osdc_watch\n        linger_reg_commit_wait\n\nIt's waiting for lreq->reg_commit_wait to be completed, but for that to\nhappen the respective request needs to end up on need_resend_linger list\nand be kicked when requests are unpaused.  There is no chance for that\nif the request in question is never marked paused in the first place.\n\nThe fact that rbd_dev->watch_mutex remains taken out forever then\nprevents the image from getting unmapped -- \"rbd unmap\" would inevitably\nhang in D state on an attempt to grab the mutex.",
  "Severity": "UNKNOWN",
  "Score": 0.0
}